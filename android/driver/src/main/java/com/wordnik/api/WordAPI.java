package com.wordnik.api;


import com.wordnik.common.*;
import com.wordnik.common.ext.*;
import com.wordnik.exception.WordnikExceptionCodes;
import com.wordnik.exception.WordnikAPIException;
import com.wordnik.model.*;
import java.util.*;
import com.wordnik.annotations.MethodArgumentNames;
import org.codehaus.jackson.map.DeserializationConfig.Feature;
import org.codehaus.jackson.map.ObjectMapper;
import org.codehaus.jackson.type.TypeReference;
import java.io.IOException;

/**
 * NOTE: This class is auto generated by the drive code generator program so please do not edit the program manually.  
 * @author ramesh
 *
 */
public class WordAPI extends AbstractWordAPI {

	/**
	 * Given a word as a string, returns the WordObject that represents it
 
	 * @param word  String value of WordObject to return
 
	 * @param useCanonical  If true will try to return the correct word root ('cats' -> 'cat'). If false returns exactly what was requested.
 
	 * @param includeSuggestions  Return suggestions (for correct spelling, case variants, etc.)
 

	 * 
	 * @return WordObject {@link WordObject}
	 * @throws WordnikAPIException 400 - Invalid word supplied.  
	 */
	 @MethodArgumentNames(value="word, useCanonical, includeSuggestions") 
	public static WordObject getWord(String word, String useCanonical, String includeSuggestions) throws WordnikAPIException {

		
		//parse inputs
		String  resourcePath = "/word.{format}/{word}";
		resourcePath = resourcePath.replace("{format}","json");
		String method = "GET";
		Map<String, String> queryParams = new HashMap<String, String>();
		
		if( useCanonical != null) {
		 	queryParams.put("useCanonical", useCanonical);
		}
		if( includeSuggestions != null) {
		 	queryParams.put("includeSuggestions", includeSuggestions);
		}

		if( word != null) {
			resourcePath = resourcePath.replace("{word}", word);
		}
		
	
		//make the API Call
		String response = invokeAPI(null, resourcePath, method, queryParams, null);
		//create output objects if the response has more than one object
        if(response == null || response.length() == 0){
            return null;
        }
		WordObject responseObject = (WordObject)deserialize(response, WordObject.class);
		return responseObject;		
				
	}
	
	
	/**
	 * Returns examples for a word
 
	 * @param wordExamplesInput  
 

	 * 
	 * @return ExampleSearchResults {@link ExampleSearchResults}
	 * @throws WordnikAPIException 400 - Invalid word supplied.  
	 */
	 @MethodArgumentNames(value="wordExamplesInput") 
	public static ExampleSearchResults getExamples(WordExamplesInput wordExamplesInput) throws WordnikAPIException {

		
		//parse inputs
		String  resourcePath = "/word.{format}/{word}/examples";
		resourcePath = resourcePath.replace("{format}","json");
		String method = "GET";
		Map<String, String> queryParams = new HashMap<String, String>();
		
		
		if( wordExamplesInput != null && wordExamplesInput.getLimit() != null) {
		 	queryParams.put("limit", wordExamplesInput.getLimit());
		}
		if( wordExamplesInput != null && wordExamplesInput.getIncludeDuplicates() != null) {
		 	queryParams.put("includeDuplicates", wordExamplesInput.getIncludeDuplicates());
		}
		if( wordExamplesInput != null && wordExamplesInput.getContentProvider() != null) {
		 	queryParams.put("contentProvider", wordExamplesInput.getContentProvider());
		}
		if( wordExamplesInput != null && wordExamplesInput.getUseCanonical() != null) {
		 	queryParams.put("useCanonical", wordExamplesInput.getUseCanonical());
		}
		if( wordExamplesInput != null && wordExamplesInput.getSkip() != null) {
		 	queryParams.put("skip", wordExamplesInput.getSkip());
		}

		if( wordExamplesInput != null && wordExamplesInput.getWord() != null) {
		 	resourcePath = resourcePath.replace("{word}", wordExamplesInput.getWord());	
		}
	
		//make the API Call
		String response = invokeAPI(null, resourcePath, method, queryParams, null);
		//create output objects if the response has more than one object
        if(response == null || response.length() == 0){
            return null;
        }
		ExampleSearchResults responseObject = (ExampleSearchResults)deserialize(response, ExampleSearchResults.class);
		return responseObject;		
				
	}
	
	
	/**
	 * Return definitions for a word
 
	 * @param wordDefinitionsInput  
 

	 * 
	 * @return List<Definition> {@link Definition}
	 * @throws WordnikAPIException 400 - Invalid word supplied. 404 - No definitions found.  
	 */
	 @MethodArgumentNames(value="wordDefinitionsInput") 
	public static List<Definition> getDefinitions(WordDefinitionsInput wordDefinitionsInput) throws WordnikAPIException {

		
		//parse inputs
		String  resourcePath = "/word.{format}/{word}/definitions";
		resourcePath = resourcePath.replace("{format}","json");
		String method = "GET";
		Map<String, String> queryParams = new HashMap<String, String>();
		
		
		if( wordDefinitionsInput != null && wordDefinitionsInput.getLimit() != null) {
		 	queryParams.put("limit", wordDefinitionsInput.getLimit());
		}
		if( wordDefinitionsInput != null && wordDefinitionsInput.getPartOfSpeech() != null) {
		 	queryParams.put("partOfSpeech", wordDefinitionsInput.getPartOfSpeech());
		}
		if( wordDefinitionsInput != null && wordDefinitionsInput.getIncludeRelated() != null) {
		 	queryParams.put("includeRelated", wordDefinitionsInput.getIncludeRelated());
		}
		if( wordDefinitionsInput != null && wordDefinitionsInput.getSourceDictionaries() != null) {
		 	queryParams.put("sourceDictionaries", wordDefinitionsInput.getSourceDictionaries());
		}
		if( wordDefinitionsInput != null && wordDefinitionsInput.getUseCanonical() != null) {
		 	queryParams.put("useCanonical", wordDefinitionsInput.getUseCanonical());
		}
		if( wordDefinitionsInput != null && wordDefinitionsInput.getIncludeTags() != null) {
		 	queryParams.put("includeTags", wordDefinitionsInput.getIncludeTags());
		}

		if( wordDefinitionsInput != null && wordDefinitionsInput.getWord() != null) {
		 	resourcePath = resourcePath.replace("{word}", wordDefinitionsInput.getWord());	
		}
	
		//make the API Call
		String response = invokeAPI(null, resourcePath, method, queryParams, null);
		//create output objects if the response has more than one object
        if(response == null || response.length() == 0){
            return null;
        }
		
        TypeReference<ArrayList<Definition>> typeRef = new TypeReference<ArrayList<Definition>>() {
		};
        try {
            List<Definition> responseObject = (List<Definition>) mapper.readValue(response, typeRef);
            return responseObject;
        } catch (IOException ioe) {
        	String[] args = new String[]{response, typeRef.toString()};
            throw new WordnikAPIException(WordnikExceptionCodes.ERROR_CONVERTING_JSON_TO_JAVA, args, "Error in converting response json value to java object : " + ioe.getMessage(), ioe);
        }						
	}
	
	
	/**
	 * Returns a top example for a word
 
	 * @param word  Word to fetch examples for
 
	 * @param contentProvider  Return results from a specific ContentProvider
 
	 * @param useCanonical  If true will try to return the correct word root ('cats' -> 'cat'). If false returns exactly what was requested.
 

	 * 
	 * @return Example {@link Example}
	 * @throws WordnikAPIException 400 - Invalid word supplied.  
	 */
	 @MethodArgumentNames(value="word, contentProvider, useCanonical") 
	public static Example getTopExample(String word, String contentProvider, String useCanonical) throws WordnikAPIException {

		
		//parse inputs
		String  resourcePath = "/word.{format}/{word}/topExample";
		resourcePath = resourcePath.replace("{format}","json");
		String method = "GET";
		Map<String, String> queryParams = new HashMap<String, String>();
		
		if( contentProvider != null) {
		 	queryParams.put("contentProvider", contentProvider);
		}
		if( useCanonical != null) {
		 	queryParams.put("useCanonical", useCanonical);
		}

		if( word != null) {
			resourcePath = resourcePath.replace("{word}", word);
		}
		
	
		//make the API Call
		String response = invokeAPI(null, resourcePath, method, queryParams, null);
		//create output objects if the response has more than one object
        if(response == null || response.length() == 0){
            return null;
        }
		Example responseObject = (Example)deserialize(response, Example.class);
		return responseObject;		
				
	}
	
	
	/**
	 * Return related words (thesaurus data) for a word
 
	 * @param wordRelatedInput  
 

	 * 
	 * @return List<Related> {@link Related}
	 * @throws WordnikAPIException 400 - Invalid word supplied. 404 - No definitions found.  
	 */
	 @MethodArgumentNames(value="wordRelatedInput") 
	public static List<Related> getRelatedWords(WordRelatedInput wordRelatedInput) throws WordnikAPIException {

		
		//parse inputs
		String  resourcePath = "/word.{format}/{word}/related";
		resourcePath = resourcePath.replace("{format}","json");
		String method = "GET";
		Map<String, String> queryParams = new HashMap<String, String>();
		
		
		if( wordRelatedInput != null && wordRelatedInput.getPartOfSpeech() != null) {
		 	queryParams.put("partOfSpeech", wordRelatedInput.getPartOfSpeech());
		}
		if( wordRelatedInput != null && wordRelatedInput.getSourceDictionary() != null) {
		 	queryParams.put("sourceDictionary", wordRelatedInput.getSourceDictionary());
		}
		if( wordRelatedInput != null && wordRelatedInput.getLimit() != null) {
		 	queryParams.put("limit", wordRelatedInput.getLimit());
		}
		if( wordRelatedInput != null && wordRelatedInput.getUseCanonical() != null) {
		 	queryParams.put("useCanonical", wordRelatedInput.getUseCanonical());
		}
		if( wordRelatedInput != null && wordRelatedInput.getType() != null) {
		 	queryParams.put("type", wordRelatedInput.getType());
		}

		if( wordRelatedInput != null && wordRelatedInput.getWord() != null) {
		 	resourcePath = resourcePath.replace("{word}", wordRelatedInput.getWord());	
		}
	
		//make the API Call
		String response = invokeAPI(null, resourcePath, method, queryParams, null);
		//create output objects if the response has more than one object
        if(response == null || response.length() == 0){
            return null;
        }
		
        TypeReference<ArrayList<Related>> typeRef = new TypeReference<ArrayList<Related>>() {
		};
        try {
            List<Related> responseObject = (List<Related>) mapper.readValue(response, typeRef);
            return responseObject;
        } catch (IOException ioe) {
        	String[] args = new String[]{response, typeRef.toString()};
            throw new WordnikAPIException(WordnikExceptionCodes.ERROR_CONVERTING_JSON_TO_JAVA, args, "Error in converting response json value to java object : " + ioe.getMessage(), ioe);
        }						
	}
	
	
	/**
	 * Fetches bi-gram phrases for a word
 
	 * @param word  Word to fetch phrases for
 
	 * @param limit  Maximum number of results to return
 
	 * @param wlmi  Minimum WLMI for the phrase
 
	 * @param useCanonical  If true will try to return the correct word root ('cats' -> 'cat'). If false returns exactly what was requested.
 

	 * 
	 * @return List<Bigram> {@link Bigram}
	 * @throws WordnikAPIException 400 - Invalid word supplied.  
	 */
	 @MethodArgumentNames(value="word, limit, wlmi, useCanonical") 
	public static List<Bigram> getPhrases(String word, String limit, String wlmi, String useCanonical) throws WordnikAPIException {

		
		//parse inputs
		String  resourcePath = "/word.{format}/{word}/phrases";
		resourcePath = resourcePath.replace("{format}","json");
		String method = "GET";
		Map<String, String> queryParams = new HashMap<String, String>();
		
		if( limit != null) {
		 	queryParams.put("limit", limit);
		}
		if( wlmi != null) {
		 	queryParams.put("wlmi", wlmi);
		}
		if( useCanonical != null) {
		 	queryParams.put("useCanonical", useCanonical);
		}

		if( word != null) {
			resourcePath = resourcePath.replace("{word}", word);
		}
		
	
		//make the API Call
		String response = invokeAPI(null, resourcePath, method, queryParams, null);
		//create output objects if the response has more than one object
        if(response == null || response.length() == 0){
            return null;
        }
		
        TypeReference<ArrayList<Bigram>> typeRef = new TypeReference<ArrayList<Bigram>>() {
		};
        try {
            List<Bigram> responseObject = (List<Bigram>) mapper.readValue(response, typeRef);
            return responseObject;
        } catch (IOException ioe) {
        	String[] args = new String[]{response, typeRef.toString()};
            throw new WordnikAPIException(WordnikExceptionCodes.ERROR_CONVERTING_JSON_TO_JAVA, args, "Error in converting response json value to java object : " + ioe.getMessage(), ioe);
        }						
	}
	
	
	/**
	 * Returns syllable information for a word
 
	 * @param word  Word to get syllables for
 
	 * @param useCanonical  If true will try to return a correct word root ('cats' -> 'cat'). If false returns exactly what was requested.
 
	 * @param sourceDictionary  Get from a single dictionary. Valid options: ahd, century, wiktionary, webster, and wordnet.
 
	 * @param limit  Maximum number of results to return
 

	 * 
	 * @return List<Syllable> {@link Syllable}
	 * @throws WordnikAPIException 400 - Invalid word supplied.  
	 */
	 @MethodArgumentNames(value="word, useCanonical, sourceDictionary, limit") 
	public static List<Syllable> getHyphenation(String word, String useCanonical, String sourceDictionary, String limit) throws WordnikAPIException {

		
		//parse inputs
		String  resourcePath = "/word.{format}/{word}/hyphenation";
		resourcePath = resourcePath.replace("{format}","json");
		String method = "GET";
		Map<String, String> queryParams = new HashMap<String, String>();
		
		if( useCanonical != null) {
		 	queryParams.put("useCanonical", useCanonical);
		}
		if( sourceDictionary != null) {
		 	queryParams.put("sourceDictionary", sourceDictionary);
		}
		if( limit != null) {
		 	queryParams.put("limit", limit);
		}

		if( word != null) {
			resourcePath = resourcePath.replace("{word}", word);
		}
		
	
		//make the API Call
		String response = invokeAPI(null, resourcePath, method, queryParams, null);
		//create output objects if the response has more than one object
        if(response == null || response.length() == 0){
            return null;
        }
		
        TypeReference<ArrayList<Syllable>> typeRef = new TypeReference<ArrayList<Syllable>>() {
		};
        try {
            List<Syllable> responseObject = (List<Syllable>) mapper.readValue(response, typeRef);
            return responseObject;
        } catch (IOException ioe) {
        	String[] args = new String[]{response, typeRef.toString()};
            throw new WordnikAPIException(WordnikExceptionCodes.ERROR_CONVERTING_JSON_TO_JAVA, args, "Error in converting response json value to java object : " + ioe.getMessage(), ioe);
        }						
	}
	
	
	/**
	 * Returns text pronunciations for a given word
 
	 * @param wordPronunciationsInput  
 

	 * 
	 * @return List<TextPron> {@link TextPron}
	 * @throws WordnikAPIException 400 - Invalid word supplied.  
	 */
	 @MethodArgumentNames(value="wordPronunciationsInput") 
	public static List<TextPron> getTextPronunciations(WordPronunciationsInput wordPronunciationsInput) throws WordnikAPIException {

		
		//parse inputs
		String  resourcePath = "/word.{format}/{word}/pronunciations";
		resourcePath = resourcePath.replace("{format}","json");
		String method = "GET";
		Map<String, String> queryParams = new HashMap<String, String>();
		
		
		if( wordPronunciationsInput != null && wordPronunciationsInput.getUseCanonical() != null) {
		 	queryParams.put("useCanonical", wordPronunciationsInput.getUseCanonical());
		}
		if( wordPronunciationsInput != null && wordPronunciationsInput.getSourceDictionary() != null) {
		 	queryParams.put("sourceDictionary", wordPronunciationsInput.getSourceDictionary());
		}
		if( wordPronunciationsInput != null && wordPronunciationsInput.getTypeFormat() != null) {
		 	queryParams.put("typeFormat", wordPronunciationsInput.getTypeFormat());
		}
		if( wordPronunciationsInput != null && wordPronunciationsInput.getLimit() != null) {
		 	queryParams.put("limit", wordPronunciationsInput.getLimit());
		}

		if( wordPronunciationsInput != null && wordPronunciationsInput.getWord() != null) {
		 	resourcePath = resourcePath.replace("{word}", wordPronunciationsInput.getWord());	
		}
	
		//make the API Call
		String response = invokeAPI(null, resourcePath, method, queryParams, null);
		//create output objects if the response has more than one object
        if(response == null || response.length() == 0){
            return null;
        }
		
        TypeReference<ArrayList<TextPron>> typeRef = new TypeReference<ArrayList<TextPron>>() {
		};
        try {
            List<TextPron> responseObject = (List<TextPron>) mapper.readValue(response, typeRef);
            return responseObject;
        } catch (IOException ioe) {
        	String[] args = new String[]{response, typeRef.toString()};
            throw new WordnikAPIException(WordnikExceptionCodes.ERROR_CONVERTING_JSON_TO_JAVA, args, "Error in converting response json value to java object : " + ioe.getMessage(), ioe);
        }						
	}
	
	
	/**
	 * Returns other forms of a word
 
	 * @param word  Word to fetch forms for
 
	 * @param useCanonical  If true will try to return a correct word root ('cats' -> 'cat'). If false returns exactly what was requested.
 

	 * 
	 * @return RelationshipMap {@link RelationshipMap}
	 * @throws WordnikAPIException 400 - Invalid word supplied. 404 - No results.  
	 */
	 @MethodArgumentNames(value="word, useCanonical") 
	public static RelationshipMap getWordForms(String word, String useCanonical) throws WordnikAPIException {

		
		//parse inputs
		String  resourcePath = "/word.{format}/{word}/wordForms";
		resourcePath = resourcePath.replace("{format}","json");
		String method = "GET";
		Map<String, String> queryParams = new HashMap<String, String>();
		
		if( useCanonical != null) {
		 	queryParams.put("useCanonical", useCanonical);
		}

		if( word != null) {
			resourcePath = resourcePath.replace("{word}", word);
		}
		
	
		//make the API Call
		String response = invokeAPI(null, resourcePath, method, queryParams, null);
		//create output objects if the response has more than one object
        if(response == null || response.length() == 0){
            return null;
        }
		RelationshipMap responseObject = (RelationshipMap)deserialize(response, RelationshipMap.class);
		return responseObject;		
				
	}
	
	
	/**
	 * Returns definitions for a word based on the sentence in which it is found
 Use the offset parameter when the word occurs more than once in the sentence
	 * @param wordContextualLookupInput  
 

	 * 
	 * @return DefinitionSearchResults {@link DefinitionSearchResults}
	 * @throws WordnikAPIException 400 - Invalid word supplied.  
	 */
	 @MethodArgumentNames(value="wordContextualLookupInput") 
	public static DefinitionSearchResults contextualLookup(WordContextualLookupInput wordContextualLookupInput) throws WordnikAPIException {

		
		//parse inputs
		String  resourcePath = "/word.{format}/{word}/contextualLookup";
		resourcePath = resourcePath.replace("{format}","json");
		String method = "GET";
		Map<String, String> queryParams = new HashMap<String, String>();
		
		
		if( wordContextualLookupInput != null && wordContextualLookupInput.getSentence() != null) {
		 	queryParams.put("sentence", wordContextualLookupInput.getSentence());
		}
		if( wordContextualLookupInput != null && wordContextualLookupInput.getOffset() != null) {
		 	queryParams.put("offset", wordContextualLookupInput.getOffset());
		}
		if( wordContextualLookupInput != null && wordContextualLookupInput.getExpandTerms() != null) {
		 	queryParams.put("expandTerms", wordContextualLookupInput.getExpandTerms());
		}
		if( wordContextualLookupInput != null && wordContextualLookupInput.getIncludeSourceDictionaries() != null) {
		 	queryParams.put("includeSourceDictionaries", wordContextualLookupInput.getIncludeSourceDictionaries());
		}
		if( wordContextualLookupInput != null && wordContextualLookupInput.getExcludeSourceDictionaries() != null) {
		 	queryParams.put("excludeSourceDictionaries", wordContextualLookupInput.getExcludeSourceDictionaries());
		}
		if( wordContextualLookupInput != null && wordContextualLookupInput.getSkip() != null) {
		 	queryParams.put("skip", wordContextualLookupInput.getSkip());
		}
		if( wordContextualLookupInput != null && wordContextualLookupInput.getLimit() != null) {
		 	queryParams.put("limit", wordContextualLookupInput.getLimit());
		}

		if( wordContextualLookupInput != null && wordContextualLookupInput.getWord() != null) {
		 	resourcePath = resourcePath.replace("{word}", wordContextualLookupInput.getWord());	
		}
	
		//make the API Call
		String response = invokeAPI(null, resourcePath, method, queryParams, null);
		//create output objects if the response has more than one object
        if(response == null || response.length() == 0){
            return null;
        }
		DefinitionSearchResults responseObject = (DefinitionSearchResults)deserialize(response, DefinitionSearchResults.class);
		return responseObject;		
				
	}
	
	
	/**
	 * Returns definitions for a word based on the sentence in which it is found
 Use the offset parameter when the word occurs more than once in the sentence
	 * @param postObject  The sentence in which the word occurs
 
	 * @param wordContextualLookupInput  
 

	 * 
	 * @return DefinitionSearchResults {@link DefinitionSearchResults}
	 * @throws WordnikAPIException 400 - Invalid term supplied.  
	 */
	 @MethodArgumentNames(value="postObject, wordContextualLookupInput") 
	public static DefinitionSearchResults contextualLookupPost(String postObject, WordContextualLookupInput wordContextualLookupInput) throws WordnikAPIException {

		
		//parse inputs
		String  resourcePath = "/word.{format}/{word}/contextualLookup";
		resourcePath = resourcePath.replace("{format}","json");
		String method = "POST";
		Map<String, String> queryParams = new HashMap<String, String>();
		
		
		if( wordContextualLookupInput != null && wordContextualLookupInput.getOffset() != null) {
		 	queryParams.put("offset", wordContextualLookupInput.getOffset());
		}
		if( wordContextualLookupInput != null && wordContextualLookupInput.getExpandTerms() != null) {
		 	queryParams.put("expandTerms", wordContextualLookupInput.getExpandTerms());
		}
		if( wordContextualLookupInput != null && wordContextualLookupInput.getIncludeSourceDictionaries() != null) {
		 	queryParams.put("includeSourceDictionaries", wordContextualLookupInput.getIncludeSourceDictionaries());
		}
		if( wordContextualLookupInput != null && wordContextualLookupInput.getExcludeSourceDictionaries() != null) {
		 	queryParams.put("excludeSourceDictionaries", wordContextualLookupInput.getExcludeSourceDictionaries());
		}
		if( wordContextualLookupInput != null && wordContextualLookupInput.getSkip() != null) {
		 	queryParams.put("skip", wordContextualLookupInput.getSkip());
		}
		if( wordContextualLookupInput != null && wordContextualLookupInput.getLimit() != null) {
		 	queryParams.put("limit", wordContextualLookupInput.getLimit());
		}

		if( wordContextualLookupInput != null && wordContextualLookupInput.getWord() != null) {
		 	resourcePath = resourcePath.replace("{word}", wordContextualLookupInput.getWord());	
		}
	
		//make the API Call
		
	
	    String response = invokeAPI(null, resourcePath, method, queryParams, postObject);		
		//create output objects if the response has more than one object
        if(response == null || response.length() == 0){
            return null;
        }
		DefinitionSearchResults responseObject = (DefinitionSearchResults)deserialize(response, DefinitionSearchResults.class);
		return responseObject;		
				
	}
	
	
	
}